/*
 * THIS FILE IS AUTOMATICALLY GENERATED
 *
 * Generator:     sensirion-driver-generator 0.32.0
 * Product:       sf06_lf
 * Model-Version: 1.1.0
 */
/*
 * Copyright (c) 2023, Sensirion AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Sensirion AG nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include "sf06_lf_i2c.h"
#include "sensirion_common.h"
#include "sensirion_i2c.h"
#include "sensirion_i2c_hal.h"

#define sensirion_hal_sleep_us sensirion_i2c_hal_sleep_usec

static uint8_t communication_buffer[18] = {0};

static uint8_t _i2c_address;

void sf06_lf_init(uint8_t i2c_address) {
    _i2c_address = i2c_address;
}

float signal_flow(int16_t raw_flow,
                  sf06_lf_inv_flow_scale_factors inv_flow_scale_factor) {
    float flow = 0.0;
    flow = (float)(raw_flow);
    flow = flow / (int)(inv_flow_scale_factor);
    return flow;
}

float signal_temperature(int16_t raw_temperature) {
    float temperature = 0.0;
    temperature = raw_temperature / 200.0;
    return temperature;
}

float signal_delta_temperature(int16_t raw_delta_temperature) {
    float delta_temperature = 0.0;
    delta_temperature = raw_delta_temperature / 1000.0;
    return delta_temperature;
}

int16_t signal_thermal_conductivity(int16_t raw_thermal_conductivity) {
    int16_t thermal_conductivity = 0;
    thermal_conductivity = raw_thermal_conductivity;
    return thermal_conductivity;
}

int16_t sf06_lf_read_measurement_data(
    sf06_lf_inv_flow_scale_factors inv_flow_scale_factor, float* a_flow,
    float* a_temperature, uint16_t* a_signaling_flags) {
    int16_t raw_flow = 0;
    int16_t raw_temp = 0;
    uint16_t signaling_flags = 0u;
    int16_t local_error = 0;
    local_error = sf06_lf_read_measurement_data_raw(&raw_flow, &raw_temp,
                                                    &signaling_flags);
    if (local_error != NO_ERROR) {
        return local_error;
    }
    *a_flow = signal_flow(raw_flow, inv_flow_scale_factor);
    *a_temperature = signal_temperature(raw_temp);
    *a_signaling_flags = signaling_flags;
    return local_error;
}

int16_t sf06_lf_read_thermal_conductivity_measurement_data(
    int16_t* a_thermal_conductivity, float* a_temperature,
    float* a_delta_temperature) {
    int16_t th_cond = 0;
    int16_t raw_temp = 0;
    int16_t raw_delta_temp = 0;
    int16_t local_error = 0;
    local_error = ll_sf06_lf_read_thermal_conductivity_measurement_data(
        &th_cond, &raw_temp, &raw_delta_temp);
    if (local_error != NO_ERROR) {
        return local_error;
    }
    *a_thermal_conductivity = signal_thermal_conductivity(th_cond);
    *a_temperature = signal_temperature(raw_temp);
    *a_delta_temperature = signal_delta_temperature(raw_delta_temp);
    return local_error;
}

int16_t sf06_lf_read_product_identifier(uint32_t* product_identifier,
                                        uint8_t* serial_number,
                                        uint16_t serial_number_size) {
    int16_t local_error = 0;
    local_error = sf06_lf_read_product_identifier_prepare();
    if (local_error != NO_ERROR) {
        return local_error;
    }
    local_error = ll_sf06_lf_read_product_identifier(
        product_identifier, serial_number, serial_number_size);
    return local_error;
}

int16_t sf06_lf_start_h2o_continuous_measurement() {
    int16_t local_error = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    uint16_t local_offset = 0;
    local_offset =
        sensirion_i2c_add_command16_to_buffer(buffer_ptr, local_offset, 0x3608);
    local_error =
        sensirion_i2c_write_data(_i2c_address, buffer_ptr, local_offset);
    if (local_error != NO_ERROR) {
        return local_error;
    }
    sensirion_i2c_hal_sleep_usec(12 * 1000);
    return local_error;
}

int16_t sf06_lf_start_ipa_continuous_measurement() {
    int16_t local_error = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    uint16_t local_offset = 0;
    local_offset =
        sensirion_i2c_add_command16_to_buffer(buffer_ptr, local_offset, 0x3615);
    local_error =
        sensirion_i2c_write_data(_i2c_address, buffer_ptr, local_offset);
    if (local_error != NO_ERROR) {
        return local_error;
    }
    sensirion_i2c_hal_sleep_usec(12 * 1000);
    return local_error;
}

int16_t sf06_lf_read_measurement_data_raw(int16_t* raw_flow,
                                          int16_t* raw_temperature,
                                          uint16_t* signaling_flags) {
    int16_t local_error = NO_ERROR;
    uint8_t buffer_ptr[9] = {0};
    local_error = sensirion_i2c_read_data_inplace(_i2c_address, buffer_ptr, 6);
    if (local_error != NO_ERROR) {
        return local_error;
    }
    *raw_flow = sensirion_common_bytes_to_int16_t(&buffer_ptr[0]);
    *raw_temperature = sensirion_common_bytes_to_int16_t(&buffer_ptr[2]);
    *signaling_flags = sensirion_common_bytes_to_uint16_t(&buffer_ptr[4]);
    return local_error;
}

int16_t sf06_lf_stop_continuous_measurement() {
    int16_t local_error = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    uint16_t local_offset = 0;
    local_offset =
        sensirion_i2c_add_command16_to_buffer(buffer_ptr, local_offset, 0x3ff9);
    local_error =
        sensirion_i2c_write_data(_i2c_address, buffer_ptr, local_offset);
    if (local_error != NO_ERROR) {
        return local_error;
    }
    sensirion_i2c_hal_sleep_usec(1 * 1000);
    return local_error;
}

int16_t sf06_lf_start_single_thermal_conductivity_measurement_sync() {
    int16_t local_error = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    uint16_t local_offset = 0;
    local_offset =
        sensirion_i2c_add_command16_to_buffer(buffer_ptr, local_offset, 0x3646);
    local_error =
        sensirion_i2c_write_data(_i2c_address, buffer_ptr, local_offset);
    if (local_error != NO_ERROR) {
        return local_error;
    }
    sensirion_i2c_hal_sleep_usec(2300 * 1000);
    return local_error;
}

int16_t sf06_lf_start_single_thermal_conductivity_measurement_async() {
    int16_t local_error = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    uint16_t local_offset = 0;
    local_offset =
        sensirion_i2c_add_command16_to_buffer(buffer_ptr, local_offset, 0x3646);
    local_error =
        sensirion_i2c_write_data(_i2c_address, buffer_ptr, local_offset);
    if (local_error != NO_ERROR) {
        return local_error;
    }
    return local_error;
}

int16_t ll_sf06_lf_read_thermal_conductivity_measurement_data(
    int16_t* thermal_conductivity, int16_t* raw_temperature,
    int16_t* raw_delta_temperature) {
    int16_t local_error = NO_ERROR;
    uint8_t buffer_ptr[9] = {0};
    local_error = sensirion_i2c_read_data_inplace(_i2c_address, buffer_ptr, 6);
    if (local_error != NO_ERROR) {
        return local_error;
    }
    *thermal_conductivity = sensirion_common_bytes_to_int16_t(&buffer_ptr[0]);
    *raw_temperature = sensirion_common_bytes_to_int16_t(&buffer_ptr[2]);
    *raw_delta_temperature = sensirion_common_bytes_to_int16_t(&buffer_ptr[4]);
    return local_error;
}

int16_t sf06_lf_enter_sleep() {
    int16_t local_error = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    uint16_t local_offset = 0;
    local_offset =
        sensirion_i2c_add_command16_to_buffer(buffer_ptr, local_offset, 0x3677);
    local_error =
        sensirion_i2c_write_data(_i2c_address, buffer_ptr, local_offset);
    if (local_error != NO_ERROR) {
        return local_error;
    }
    return local_error;
}

int16_t sf06_lf_exit_sleep() {
    int16_t local_error = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    uint16_t local_offset = 0;
    local_offset =
        sensirion_i2c_add_command8_to_buffer(buffer_ptr, local_offset, 0x0);
    sensirion_i2c_write_data(_i2c_address, buffer_ptr, local_offset);
    sensirion_i2c_hal_sleep_usec(25 * 1000);
    return local_error;
}

int16_t sf06_lf_read_product_identifier_prepare() {
    int16_t local_error = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    uint16_t local_offset = 0;
    local_offset =
        sensirion_i2c_add_command16_to_buffer(buffer_ptr, local_offset, 0x367c);
    local_error =
        sensirion_i2c_write_data(_i2c_address, buffer_ptr, local_offset);
    if (local_error != NO_ERROR) {
        return local_error;
    }
    return local_error;
}

int16_t ll_sf06_lf_read_product_identifier(uint32_t* product_identifier,
                                           uint8_t* serial_number,
                                           uint16_t serial_number_size) {
    int16_t local_error = NO_ERROR;
    uint8_t* buffer_ptr = communication_buffer;
    uint16_t local_offset = 0;
    local_offset =
        sensirion_i2c_add_command16_to_buffer(buffer_ptr, local_offset, 0xe102);
    local_error =
        sensirion_i2c_write_data(_i2c_address, buffer_ptr, local_offset);
    if (local_error != NO_ERROR) {
        return local_error;
    }
    local_error = sensirion_i2c_read_data_inplace(_i2c_address, buffer_ptr, 12);
    if (local_error != NO_ERROR) {
        return local_error;
    }
    *product_identifier = sensirion_common_bytes_to_uint32_t(&buffer_ptr[0]);
    sensirion_common_copy_bytes(&buffer_ptr[4], (uint8_t*)serial_number,
                                serial_number_size);
    return local_error;
}
